#
# Autogenerated by Thrift Compiler (0.19.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def requestNotifications(self, subscriberInfo):
        """
        Requests notifications about line state change, login state change, login errors and change on top of call queue.

        Parameters:
         - subscriberInfo: SubscriberInfo IP address and port of the requesting client; Optionally contains turret display name

        """
        pass

    def getProfileList(self):
        """
        Requests and returns the list of the available profiles

        """
        pass

    def getLoggedInProfileName(self):
        """
        Requests and returns the name of the currently logged in profile

        """
        pass

    def getSpeechUnits(self):
        """
        Requests and returns the current speech unit configuration setup in the system for the actual client.

        See :thrift:struct:`TurretApi.SpeechUnitConfiguration` for included information.

        """
        pass

    def getAvailableLines(self):
        """
        Requests and returns a list about the identifiers of the available lines.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if the turret is logged out.

        """
        pass

    def snapshotLineRequest(self, lineName):
        """
        Requests the state of the line specified by lineName.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if the turret is logged out or line name is invalid.

        Parameters:
         - lineName: Identifier of the requested line

        """
        pass

    def snapshotCalls(self):
        """
        Request the state of the current calls.
        See :thrift:struct:`TurretApi.CallData` for the included information.

        """
        pass

    def login(self, profileName, password):
        """
        Requests the turret to log in with the specified profile name and password.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if the turret is already logged in.
        A successful call of this function only means that the request is forwarded to the System Manager;
        The actual response will arrive in a login response notification
        (see :thrift:service_method:`TurretApi.TurretNotificationService.onLoginResponse`)

        Parameters:
         - profileName: Name of the profile
         - password: Profile's password

        """
        pass

    def logout(self):
        """
        Requests the turret to log out of the currently logged in profile.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if the turret is already logged out.

        """
        pass

    def makeCall(self, suId, number):
        """
        Requests the turret to dial the given number from the specified speech unit.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if speech unit id is invalid, the speech unit is busy or there is
        no free line to initiate a call from.

        Parameters:
         - suId: Speech unit identifier
         - number: Telephone number to call

        """
        pass

    def makeCallFromSpecificLine(self, suId, lineName, number):
        """
        Requests the turret to dial the given number from the specified speech unit using a certain line.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if speech unit id or lineName is invalid, the speech unit or line is
        busy or the line is unavailable.

        Parameters:
         - suId: Speech unit identifier
         - lineName: Line identifier from which the call will be initiated
         - number: Telephone number to call

        """
        pass

    def createConsultation(self, suId, number):
        """
        Request the turret to create a *Consultation* on ``suId`` by calling ``number``.
        It is prerequisite that there is a line on ``suId`` and it is ``Connected``.

        Parameters:
         - suId: Speech unit identifier
         - number: Telephone number to call

        """
        pass

    def transfer(self, suId):
        """
        Request the turret to execute *Transfer* on the given ``suId``.
        The line seized on ``suId`` must have the ``HostingConsultation`` state.

        Parameters:
         - suId: Speech unit identifier

        """
        pass

    def toggle(self, suId):
        """
        Request the turret to execute *Toggle* on the given ``suId``.
        The line seized on ``suId`` must have the ``HostingConsultation`` state.

        Parameters:
         - suId: Speech unit identifier

        """
        pass

    def pbxConference(self, suId):
        """
        Request the turret to create a *PBX Conference* (max. 3 participants) on the given ``suId``.
        The line seized on ``suId`` must have the ``HostingConsultation`` state.
        If the request was successful, the line on the given ``suId`` will have the ``HostingPbxConference`` state.

        Parameters:
         - suId: Speech unit identifier

        """
        pass

    def answerCall(self, suId):
        """
        Answers the incoming call with the highest priority in the call queue.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if speech unit id is invalid or the speech unit is busy.

        Parameters:
         - suId: Receiver speech unit's identifier

        """
        pass

    def answerSpecificCall(self, suId, lineName):
        """
        Answers the incoming call on the line specified by lineName.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if speech unit id or lineName is invalid, the speech unit is busy or
        there is no incoming call on the specified line.

        Parameters:
         - suId: Receiver speech unit's identifier
         - lineName: Ringing line's identifier which will be picked up

        """
        pass

    def disconnectCall(self, suId):
        """
        Disconnects the call present on the speech unit specified by suId
        :thrift:struct:`TurretApi.TurretApiException` is thrown if the speech unit id is invalid, there is no ongoing call on the speech unit,
        or the turret is not logged in.

        Parameters:
         - suId: Receiver speech unit's identifier

        """
        pass

    def hold(self, suId):
        """
        Puts the call on hold from the given speech unit.

        Possible values for :thrift:struct_field:`TurretApi.TurretApiException.ErrorCode`:
            #. :thrift:constant:`TurretApi.InvalidSpeechUnit` speech unit id is invalid
            #. :thrift:constant:`TurretApi.SpeechUnitHasNoCall` there is no call on the given speech unit,
            #. :thrift:constant:`TurretApi.FunctionUnavailable` the hold function is unavailable

        Parameters:
         - suId: Speech unit identifier

        """
        pass

    def commonHold(self, suId):
        """
        Put the call on the specified speech unit to common (SIP) hold, ie. hold on all turret subscribed to the line.

        Possible values for :thrift:struct_field:`TurretApi.TurretApiException.ErrorCode`:
            #. :thrift:constant:`TurretApi.InvalidSpeechUnit` speech unit id is invalid
            #. :thrift:constant:`TurretApi.SpeechUnitHasNoCall` there is no call on the given speech unit,
            #. :thrift:constant:`TurretApi.FunctionUnavailable` the common hold function is unavailable
            #. :thrift:constant:`TurretApi.FunctionUnavailable` the hold behaviour is set to private.

        Parameters:
         - suId: Speech unit identifier

        """
        pass

    def privateHold(self, suId):
        """
        Puts the call on private hold from the given speech unit.

        Possible values for :thrift:struct_field:`TurretApi.TurretApiException.ErrorCode`:
            #. :thrift:constant:`TurretApi.InvalidSpeechUnit` speech unit id is invalid
            #. :thrift:constant:`TurretApi.SpeechUnitHasNoCall` there is no call on the given speech unit,
            #. :thrift:constant:`TurretApi.FunctionUnavailable` the private hold function is unavailable

        Parameters:
         - suId: Speech unit identifier

        """
        pass

    def retrieveSpecific(self, suId, lineName):
        """
        Retrieves the call from hold to the given speech unit.

        Possible values for :thrift:struct_field:`TurretApi.TurretApiException.ErrorCode`:
            #. :thrift:constant:`TurretApi.InvalidSpeechUnit` speech unit id is invalid
            #. :thrift:constant:`TurretApi.InvalidLine` the lineName is invalid
            #. :thrift:constant:`TurretApi.LineIsNotInHold` the line is not in hold

        Parameters:
         - suId: Speech unit identifier
         - lineName: Unique name of the Line

        """
        pass

    def dtmf(self, suId, digit):
        """
        Sends DTMF on the line which is connected on the specified speech unit.

        Possible values for :thrift:struct_field:`TurretApi.TurretApiException.ErrorCode`:
           #. :thrift:constant:`TurretApi.InvalidArgument` digit is not a valid DTMF digit
           #. :thrift:constant:`TurretApi.InvalidSpeechUnit` speech unit id is invalid
           #. :thrift:constant:`TurretApi.SpeechUnitHasNoCall` there is no call on the speech unit
           #. :thrift:constant:`TurretApi.FunctionUnavailable` the call does not accept DTMF

        Parameters:
         - suId: Speech unit identifier
         - digit: DTMF digit to send

        """
        pass

    def getLoginState(self):
        """
        Requests the current login state of the turret

        """
        pass

    def getVersion(self):
        """
        Requests the version of the turret software.

        """
        pass

    def getAvailableRingTransfers(self):
        """
        Requests the list of available ring transfers

        """
        pass

    def snapshotRingTransfer(self, id):
        """
        Requests the current state of the ring transfer

        Parameters:
         - id

        """
        pass

    def setRingTransferActive(self, id, active):
        """
        Sets the ring transfer's state

        Parameters:
         - id
         - active

        """
        pass

    def getAvailableRingtransferSequences(self):
        """
        Requests the list of available ring transfer sequences

        """
        pass

    def snapshotRingTransferSequence(self, id):
        """
        Requests the current state of the ring transfer sequence

        Parameters:
         - id

        """
        pass

    def setRingTransferSequenceActive(self, id, active):
        """
        Sets the ring transfer sequence's state

        Parameters:
         - id
         - active

        """
        pass

    def getAvailableInterfaceActions(self):
        """
        Requests the list of available interface actions

        """
        pass

    def snapshotInterfaceAction(self, apiName):
        """
        Requests the current state of the interface action including the displayed texts

        Parameters:
         - apiName

        """
        pass

    def setInterfaceActionState(self, apiName, state):
        """
        Sets the interface action's state
        The texts within InterfaceActionState are optional. The texts are not changed if they are not specified.
        The texts can be reset to their original value by setting an empty string.

        Parameters:
         - apiName
         - state

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def requestNotifications(self, subscriberInfo):
        """
        Requests notifications about line state change, login state change, login errors and change on top of call queue.

        Parameters:
         - subscriberInfo: SubscriberInfo IP address and port of the requesting client; Optionally contains turret display name

        """
        self.send_requestNotifications(subscriberInfo)
        self.recv_requestNotifications()

    def send_requestNotifications(self, subscriberInfo):
        self._oprot.writeMessageBegin('requestNotifications', TMessageType.CALL, self._seqid)
        args = requestNotifications_args()
        args.subscriberInfo = subscriberInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_requestNotifications(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = requestNotifications_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def getProfileList(self):
        """
        Requests and returns the list of the available profiles

        """
        self.send_getProfileList()
        return self.recv_getProfileList()

    def send_getProfileList(self):
        self._oprot.writeMessageBegin('getProfileList', TMessageType.CALL, self._seqid)
        args = getProfileList_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getProfileList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getProfileList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getProfileList failed: unknown result")

    def getLoggedInProfileName(self):
        """
        Requests and returns the name of the currently logged in profile

        """
        self.send_getLoggedInProfileName()
        return self.recv_getLoggedInProfileName()

    def send_getLoggedInProfileName(self):
        self._oprot.writeMessageBegin('getLoggedInProfileName', TMessageType.CALL, self._seqid)
        args = getLoggedInProfileName_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLoggedInProfileName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLoggedInProfileName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLoggedInProfileName failed: unknown result")

    def getSpeechUnits(self):
        """
        Requests and returns the current speech unit configuration setup in the system for the actual client.

        See :thrift:struct:`TurretApi.SpeechUnitConfiguration` for included information.

        """
        self.send_getSpeechUnits()
        return self.recv_getSpeechUnits()

    def send_getSpeechUnits(self):
        self._oprot.writeMessageBegin('getSpeechUnits', TMessageType.CALL, self._seqid)
        args = getSpeechUnits_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSpeechUnits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSpeechUnits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSpeechUnits failed: unknown result")

    def getAvailableLines(self):
        """
        Requests and returns a list about the identifiers of the available lines.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if the turret is logged out.

        """
        self.send_getAvailableLines()
        return self.recv_getAvailableLines()

    def send_getAvailableLines(self):
        self._oprot.writeMessageBegin('getAvailableLines', TMessageType.CALL, self._seqid)
        args = getAvailableLines_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAvailableLines(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAvailableLines_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAvailableLines failed: unknown result")

    def snapshotLineRequest(self, lineName):
        """
        Requests the state of the line specified by lineName.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if the turret is logged out or line name is invalid.

        Parameters:
         - lineName: Identifier of the requested line

        """
        self.send_snapshotLineRequest(lineName)
        return self.recv_snapshotLineRequest()

    def send_snapshotLineRequest(self, lineName):
        self._oprot.writeMessageBegin('snapshotLineRequest', TMessageType.CALL, self._seqid)
        args = snapshotLineRequest_args()
        args.lineName = lineName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshotLineRequest(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshotLineRequest_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshotLineRequest failed: unknown result")

    def snapshotCalls(self):
        """
        Request the state of the current calls.
        See :thrift:struct:`TurretApi.CallData` for the included information.

        """
        self.send_snapshotCalls()
        return self.recv_snapshotCalls()

    def send_snapshotCalls(self):
        self._oprot.writeMessageBegin('snapshotCalls', TMessageType.CALL, self._seqid)
        args = snapshotCalls_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshotCalls(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshotCalls_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshotCalls failed: unknown result")

    def login(self, profileName, password):
        """
        Requests the turret to log in with the specified profile name and password.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if the turret is already logged in.
        A successful call of this function only means that the request is forwarded to the System Manager;
        The actual response will arrive in a login response notification
        (see :thrift:service_method:`TurretApi.TurretNotificationService.onLoginResponse`)

        Parameters:
         - profileName: Name of the profile
         - password: Profile's password

        """
        self.send_login(profileName, password)
        self.recv_login()

    def send_login(self, profileName, password):
        self._oprot.writeMessageBegin('login', TMessageType.CALL, self._seqid)
        args = login_args()
        args.profileName = profileName
        args.password = password
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_login(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = login_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def logout(self):
        """
        Requests the turret to log out of the currently logged in profile.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if the turret is already logged out.

        """
        self.send_logout()
        self.recv_logout()

    def send_logout(self):
        self._oprot.writeMessageBegin('logout', TMessageType.CALL, self._seqid)
        args = logout_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_logout(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = logout_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def makeCall(self, suId, number):
        """
        Requests the turret to dial the given number from the specified speech unit.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if speech unit id is invalid, the speech unit is busy or there is
        no free line to initiate a call from.

        Parameters:
         - suId: Speech unit identifier
         - number: Telephone number to call

        """
        self.send_makeCall(suId, number)
        self.recv_makeCall()

    def send_makeCall(self, suId, number):
        self._oprot.writeMessageBegin('makeCall', TMessageType.CALL, self._seqid)
        args = makeCall_args()
        args.suId = suId
        args.number = number
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_makeCall(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = makeCall_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def makeCallFromSpecificLine(self, suId, lineName, number):
        """
        Requests the turret to dial the given number from the specified speech unit using a certain line.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if speech unit id or lineName is invalid, the speech unit or line is
        busy or the line is unavailable.

        Parameters:
         - suId: Speech unit identifier
         - lineName: Line identifier from which the call will be initiated
         - number: Telephone number to call

        """
        self.send_makeCallFromSpecificLine(suId, lineName, number)
        self.recv_makeCallFromSpecificLine()

    def send_makeCallFromSpecificLine(self, suId, lineName, number):
        self._oprot.writeMessageBegin('makeCallFromSpecificLine', TMessageType.CALL, self._seqid)
        args = makeCallFromSpecificLine_args()
        args.suId = suId
        args.lineName = lineName
        args.number = number
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_makeCallFromSpecificLine(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = makeCallFromSpecificLine_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def createConsultation(self, suId, number):
        """
        Request the turret to create a *Consultation* on ``suId`` by calling ``number``.
        It is prerequisite that there is a line on ``suId`` and it is ``Connected``.

        Parameters:
         - suId: Speech unit identifier
         - number: Telephone number to call

        """
        self.send_createConsultation(suId, number)
        self.recv_createConsultation()

    def send_createConsultation(self, suId, number):
        self._oprot.writeMessageBegin('createConsultation', TMessageType.CALL, self._seqid)
        args = createConsultation_args()
        args.suId = suId
        args.number = number
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createConsultation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createConsultation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def transfer(self, suId):
        """
        Request the turret to execute *Transfer* on the given ``suId``.
        The line seized on ``suId`` must have the ``HostingConsultation`` state.

        Parameters:
         - suId: Speech unit identifier

        """
        self.send_transfer(suId)
        self.recv_transfer()

    def send_transfer(self, suId):
        self._oprot.writeMessageBegin('transfer', TMessageType.CALL, self._seqid)
        args = transfer_args()
        args.suId = suId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_transfer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = transfer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def toggle(self, suId):
        """
        Request the turret to execute *Toggle* on the given ``suId``.
        The line seized on ``suId`` must have the ``HostingConsultation`` state.

        Parameters:
         - suId: Speech unit identifier

        """
        self.send_toggle(suId)
        self.recv_toggle()

    def send_toggle(self, suId):
        self._oprot.writeMessageBegin('toggle', TMessageType.CALL, self._seqid)
        args = toggle_args()
        args.suId = suId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_toggle(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = toggle_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def pbxConference(self, suId):
        """
        Request the turret to create a *PBX Conference* (max. 3 participants) on the given ``suId``.
        The line seized on ``suId`` must have the ``HostingConsultation`` state.
        If the request was successful, the line on the given ``suId`` will have the ``HostingPbxConference`` state.

        Parameters:
         - suId: Speech unit identifier

        """
        self.send_pbxConference(suId)
        self.recv_pbxConference()

    def send_pbxConference(self, suId):
        self._oprot.writeMessageBegin('pbxConference', TMessageType.CALL, self._seqid)
        args = pbxConference_args()
        args.suId = suId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pbxConference(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pbxConference_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def answerCall(self, suId):
        """
        Answers the incoming call with the highest priority in the call queue.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if speech unit id is invalid or the speech unit is busy.

        Parameters:
         - suId: Receiver speech unit's identifier

        """
        self.send_answerCall(suId)
        self.recv_answerCall()

    def send_answerCall(self, suId):
        self._oprot.writeMessageBegin('answerCall', TMessageType.CALL, self._seqid)
        args = answerCall_args()
        args.suId = suId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_answerCall(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = answerCall_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def answerSpecificCall(self, suId, lineName):
        """
        Answers the incoming call on the line specified by lineName.
        :thrift:struct:`TurretApi.TurretApiException` is thrown if speech unit id or lineName is invalid, the speech unit is busy or
        there is no incoming call on the specified line.

        Parameters:
         - suId: Receiver speech unit's identifier
         - lineName: Ringing line's identifier which will be picked up

        """
        self.send_answerSpecificCall(suId, lineName)
        self.recv_answerSpecificCall()

    def send_answerSpecificCall(self, suId, lineName):
        self._oprot.writeMessageBegin('answerSpecificCall', TMessageType.CALL, self._seqid)
        args = answerSpecificCall_args()
        args.suId = suId
        args.lineName = lineName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_answerSpecificCall(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = answerSpecificCall_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def disconnectCall(self, suId):
        """
        Disconnects the call present on the speech unit specified by suId
        :thrift:struct:`TurretApi.TurretApiException` is thrown if the speech unit id is invalid, there is no ongoing call on the speech unit,
        or the turret is not logged in.

        Parameters:
         - suId: Receiver speech unit's identifier

        """
        self.send_disconnectCall(suId)
        self.recv_disconnectCall()

    def send_disconnectCall(self, suId):
        self._oprot.writeMessageBegin('disconnectCall', TMessageType.CALL, self._seqid)
        args = disconnectCall_args()
        args.suId = suId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disconnectCall(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disconnectCall_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def hold(self, suId):
        """
        Puts the call on hold from the given speech unit.

        Possible values for :thrift:struct_field:`TurretApi.TurretApiException.ErrorCode`:
            #. :thrift:constant:`TurretApi.InvalidSpeechUnit` speech unit id is invalid
            #. :thrift:constant:`TurretApi.SpeechUnitHasNoCall` there is no call on the given speech unit,
            #. :thrift:constant:`TurretApi.FunctionUnavailable` the hold function is unavailable

        Parameters:
         - suId: Speech unit identifier

        """
        self.send_hold(suId)
        self.recv_hold()

    def send_hold(self, suId):
        self._oprot.writeMessageBegin('hold', TMessageType.CALL, self._seqid)
        args = hold_args()
        args.suId = suId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hold(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hold_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def commonHold(self, suId):
        """
        Put the call on the specified speech unit to common (SIP) hold, ie. hold on all turret subscribed to the line.

        Possible values for :thrift:struct_field:`TurretApi.TurretApiException.ErrorCode`:
            #. :thrift:constant:`TurretApi.InvalidSpeechUnit` speech unit id is invalid
            #. :thrift:constant:`TurretApi.SpeechUnitHasNoCall` there is no call on the given speech unit,
            #. :thrift:constant:`TurretApi.FunctionUnavailable` the common hold function is unavailable
            #. :thrift:constant:`TurretApi.FunctionUnavailable` the hold behaviour is set to private.

        Parameters:
         - suId: Speech unit identifier

        """
        self.send_commonHold(suId)
        self.recv_commonHold()

    def send_commonHold(self, suId):
        self._oprot.writeMessageBegin('commonHold', TMessageType.CALL, self._seqid)
        args = commonHold_args()
        args.suId = suId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_commonHold(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = commonHold_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def privateHold(self, suId):
        """
        Puts the call on private hold from the given speech unit.

        Possible values for :thrift:struct_field:`TurretApi.TurretApiException.ErrorCode`:
            #. :thrift:constant:`TurretApi.InvalidSpeechUnit` speech unit id is invalid
            #. :thrift:constant:`TurretApi.SpeechUnitHasNoCall` there is no call on the given speech unit,
            #. :thrift:constant:`TurretApi.FunctionUnavailable` the private hold function is unavailable

        Parameters:
         - suId: Speech unit identifier

        """
        self.send_privateHold(suId)
        self.recv_privateHold()

    def send_privateHold(self, suId):
        self._oprot.writeMessageBegin('privateHold', TMessageType.CALL, self._seqid)
        args = privateHold_args()
        args.suId = suId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_privateHold(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = privateHold_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def retrieveSpecific(self, suId, lineName):
        """
        Retrieves the call from hold to the given speech unit.

        Possible values for :thrift:struct_field:`TurretApi.TurretApiException.ErrorCode`:
            #. :thrift:constant:`TurretApi.InvalidSpeechUnit` speech unit id is invalid
            #. :thrift:constant:`TurretApi.InvalidLine` the lineName is invalid
            #. :thrift:constant:`TurretApi.LineIsNotInHold` the line is not in hold

        Parameters:
         - suId: Speech unit identifier
         - lineName: Unique name of the Line

        """
        self.send_retrieveSpecific(suId, lineName)
        self.recv_retrieveSpecific()

    def send_retrieveSpecific(self, suId, lineName):
        self._oprot.writeMessageBegin('retrieveSpecific', TMessageType.CALL, self._seqid)
        args = retrieveSpecific_args()
        args.suId = suId
        args.lineName = lineName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_retrieveSpecific(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = retrieveSpecific_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def dtmf(self, suId, digit):
        """
        Sends DTMF on the line which is connected on the specified speech unit.

        Possible values for :thrift:struct_field:`TurretApi.TurretApiException.ErrorCode`:
           #. :thrift:constant:`TurretApi.InvalidArgument` digit is not a valid DTMF digit
           #. :thrift:constant:`TurretApi.InvalidSpeechUnit` speech unit id is invalid
           #. :thrift:constant:`TurretApi.SpeechUnitHasNoCall` there is no call on the speech unit
           #. :thrift:constant:`TurretApi.FunctionUnavailable` the call does not accept DTMF

        Parameters:
         - suId: Speech unit identifier
         - digit: DTMF digit to send

        """
        self.send_dtmf(suId, digit)
        self.recv_dtmf()

    def send_dtmf(self, suId, digit):
        self._oprot.writeMessageBegin('dtmf', TMessageType.CALL, self._seqid)
        args = dtmf_args()
        args.suId = suId
        args.digit = digit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dtmf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dtmf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def getLoginState(self):
        """
        Requests the current login state of the turret

        """
        self.send_getLoginState()
        return self.recv_getLoginState()

    def send_getLoginState(self):
        self._oprot.writeMessageBegin('getLoginState', TMessageType.CALL, self._seqid)
        args = getLoginState_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLoginState(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLoginState_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLoginState failed: unknown result")

    def getVersion(self):
        """
        Requests the version of the turret software.

        """
        self.send_getVersion()
        return self.recv_getVersion()

    def send_getVersion(self):
        self._oprot.writeMessageBegin('getVersion', TMessageType.CALL, self._seqid)
        args = getVersion_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getVersion(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getVersion_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getVersion failed: unknown result")

    def getAvailableRingTransfers(self):
        """
        Requests the list of available ring transfers

        """
        self.send_getAvailableRingTransfers()
        return self.recv_getAvailableRingTransfers()

    def send_getAvailableRingTransfers(self):
        self._oprot.writeMessageBegin('getAvailableRingTransfers', TMessageType.CALL, self._seqid)
        args = getAvailableRingTransfers_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAvailableRingTransfers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAvailableRingTransfers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAvailableRingTransfers failed: unknown result")

    def snapshotRingTransfer(self, id):
        """
        Requests the current state of the ring transfer

        Parameters:
         - id

        """
        self.send_snapshotRingTransfer(id)
        return self.recv_snapshotRingTransfer()

    def send_snapshotRingTransfer(self, id):
        self._oprot.writeMessageBegin('snapshotRingTransfer', TMessageType.CALL, self._seqid)
        args = snapshotRingTransfer_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshotRingTransfer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshotRingTransfer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshotRingTransfer failed: unknown result")

    def setRingTransferActive(self, id, active):
        """
        Sets the ring transfer's state

        Parameters:
         - id
         - active

        """
        self.send_setRingTransferActive(id, active)
        self.recv_setRingTransferActive()

    def send_setRingTransferActive(self, id, active):
        self._oprot.writeMessageBegin('setRingTransferActive', TMessageType.CALL, self._seqid)
        args = setRingTransferActive_args()
        args.id = id
        args.active = active
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setRingTransferActive(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setRingTransferActive_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def getAvailableRingtransferSequences(self):
        """
        Requests the list of available ring transfer sequences

        """
        self.send_getAvailableRingtransferSequences()
        return self.recv_getAvailableRingtransferSequences()

    def send_getAvailableRingtransferSequences(self):
        self._oprot.writeMessageBegin('getAvailableRingtransferSequences', TMessageType.CALL, self._seqid)
        args = getAvailableRingtransferSequences_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAvailableRingtransferSequences(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAvailableRingtransferSequences_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAvailableRingtransferSequences failed: unknown result")

    def snapshotRingTransferSequence(self, id):
        """
        Requests the current state of the ring transfer sequence

        Parameters:
         - id

        """
        self.send_snapshotRingTransferSequence(id)
        return self.recv_snapshotRingTransferSequence()

    def send_snapshotRingTransferSequence(self, id):
        self._oprot.writeMessageBegin('snapshotRingTransferSequence', TMessageType.CALL, self._seqid)
        args = snapshotRingTransferSequence_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshotRingTransferSequence(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshotRingTransferSequence_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshotRingTransferSequence failed: unknown result")

    def setRingTransferSequenceActive(self, id, active):
        """
        Sets the ring transfer sequence's state

        Parameters:
         - id
         - active

        """
        self.send_setRingTransferSequenceActive(id, active)
        self.recv_setRingTransferSequenceActive()

    def send_setRingTransferSequenceActive(self, id, active):
        self._oprot.writeMessageBegin('setRingTransferSequenceActive', TMessageType.CALL, self._seqid)
        args = setRingTransferSequenceActive_args()
        args.id = id
        args.active = active
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setRingTransferSequenceActive(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setRingTransferSequenceActive_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def getAvailableInterfaceActions(self):
        """
        Requests the list of available interface actions

        """
        self.send_getAvailableInterfaceActions()
        return self.recv_getAvailableInterfaceActions()

    def send_getAvailableInterfaceActions(self):
        self._oprot.writeMessageBegin('getAvailableInterfaceActions', TMessageType.CALL, self._seqid)
        args = getAvailableInterfaceActions_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAvailableInterfaceActions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAvailableInterfaceActions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAvailableInterfaceActions failed: unknown result")

    def snapshotInterfaceAction(self, apiName):
        """
        Requests the current state of the interface action including the displayed texts

        Parameters:
         - apiName

        """
        self.send_snapshotInterfaceAction(apiName)
        return self.recv_snapshotInterfaceAction()

    def send_snapshotInterfaceAction(self, apiName):
        self._oprot.writeMessageBegin('snapshotInterfaceAction', TMessageType.CALL, self._seqid)
        args = snapshotInterfaceAction_args()
        args.apiName = apiName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshotInterfaceAction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshotInterfaceAction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshotInterfaceAction failed: unknown result")

    def setInterfaceActionState(self, apiName, state):
        """
        Sets the interface action's state
        The texts within InterfaceActionState are optional. The texts are not changed if they are not specified.
        The texts can be reset to their original value by setting an empty string.

        Parameters:
         - apiName
         - state

        """
        self.send_setInterfaceActionState(apiName, state)
        self.recv_setInterfaceActionState()

    def send_setInterfaceActionState(self, apiName, state):
        self._oprot.writeMessageBegin('setInterfaceActionState', TMessageType.CALL, self._seqid)
        args = setInterfaceActionState_args()
        args.apiName = apiName
        args.state = state
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setInterfaceActionState(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setInterfaceActionState_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["requestNotifications"] = Processor.process_requestNotifications
        self._processMap["getProfileList"] = Processor.process_getProfileList
        self._processMap["getLoggedInProfileName"] = Processor.process_getLoggedInProfileName
        self._processMap["getSpeechUnits"] = Processor.process_getSpeechUnits
        self._processMap["getAvailableLines"] = Processor.process_getAvailableLines
        self._processMap["snapshotLineRequest"] = Processor.process_snapshotLineRequest
        self._processMap["snapshotCalls"] = Processor.process_snapshotCalls
        self._processMap["login"] = Processor.process_login
        self._processMap["logout"] = Processor.process_logout
        self._processMap["makeCall"] = Processor.process_makeCall
        self._processMap["makeCallFromSpecificLine"] = Processor.process_makeCallFromSpecificLine
        self._processMap["createConsultation"] = Processor.process_createConsultation
        self._processMap["transfer"] = Processor.process_transfer
        self._processMap["toggle"] = Processor.process_toggle
        self._processMap["pbxConference"] = Processor.process_pbxConference
        self._processMap["answerCall"] = Processor.process_answerCall
        self._processMap["answerSpecificCall"] = Processor.process_answerSpecificCall
        self._processMap["disconnectCall"] = Processor.process_disconnectCall
        self._processMap["hold"] = Processor.process_hold
        self._processMap["commonHold"] = Processor.process_commonHold
        self._processMap["privateHold"] = Processor.process_privateHold
        self._processMap["retrieveSpecific"] = Processor.process_retrieveSpecific
        self._processMap["dtmf"] = Processor.process_dtmf
        self._processMap["getLoginState"] = Processor.process_getLoginState
        self._processMap["getVersion"] = Processor.process_getVersion
        self._processMap["getAvailableRingTransfers"] = Processor.process_getAvailableRingTransfers
        self._processMap["snapshotRingTransfer"] = Processor.process_snapshotRingTransfer
        self._processMap["setRingTransferActive"] = Processor.process_setRingTransferActive
        self._processMap["getAvailableRingtransferSequences"] = Processor.process_getAvailableRingtransferSequences
        self._processMap["snapshotRingTransferSequence"] = Processor.process_snapshotRingTransferSequence
        self._processMap["setRingTransferSequenceActive"] = Processor.process_setRingTransferSequenceActive
        self._processMap["getAvailableInterfaceActions"] = Processor.process_getAvailableInterfaceActions
        self._processMap["snapshotInterfaceAction"] = Processor.process_snapshotInterfaceAction
        self._processMap["setInterfaceActionState"] = Processor.process_setInterfaceActionState
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_requestNotifications(self, seqid, iprot, oprot):
        args = requestNotifications_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = requestNotifications_result()
        try:
            self._handler.requestNotifications(args.subscriberInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("requestNotifications", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getProfileList(self, seqid, iprot, oprot):
        args = getProfileList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProfileList_result()
        try:
            result.success = self._handler.getProfileList()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getProfileList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLoggedInProfileName(self, seqid, iprot, oprot):
        args = getLoggedInProfileName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLoggedInProfileName_result()
        try:
            result.success = self._handler.getLoggedInProfileName()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLoggedInProfileName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSpeechUnits(self, seqid, iprot, oprot):
        args = getSpeechUnits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSpeechUnits_result()
        try:
            result.success = self._handler.getSpeechUnits()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSpeechUnits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAvailableLines(self, seqid, iprot, oprot):
        args = getAvailableLines_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAvailableLines_result()
        try:
            result.success = self._handler.getAvailableLines()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAvailableLines", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshotLineRequest(self, seqid, iprot, oprot):
        args = snapshotLineRequest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshotLineRequest_result()
        try:
            result.success = self._handler.snapshotLineRequest(args.lineName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshotLineRequest", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshotCalls(self, seqid, iprot, oprot):
        args = snapshotCalls_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshotCalls_result()
        try:
            result.success = self._handler.snapshotCalls()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshotCalls", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_login(self, seqid, iprot, oprot):
        args = login_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = login_result()
        try:
            self._handler.login(args.profileName, args.password)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("login", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_logout(self, seqid, iprot, oprot):
        args = logout_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = logout_result()
        try:
            self._handler.logout()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("logout", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_makeCall(self, seqid, iprot, oprot):
        args = makeCall_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = makeCall_result()
        try:
            self._handler.makeCall(args.suId, args.number)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("makeCall", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_makeCallFromSpecificLine(self, seqid, iprot, oprot):
        args = makeCallFromSpecificLine_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = makeCallFromSpecificLine_result()
        try:
            self._handler.makeCallFromSpecificLine(args.suId, args.lineName, args.number)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("makeCallFromSpecificLine", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createConsultation(self, seqid, iprot, oprot):
        args = createConsultation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createConsultation_result()
        try:
            self._handler.createConsultation(args.suId, args.number)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createConsultation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_transfer(self, seqid, iprot, oprot):
        args = transfer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = transfer_result()
        try:
            self._handler.transfer(args.suId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("transfer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_toggle(self, seqid, iprot, oprot):
        args = toggle_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = toggle_result()
        try:
            self._handler.toggle(args.suId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("toggle", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pbxConference(self, seqid, iprot, oprot):
        args = pbxConference_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pbxConference_result()
        try:
            self._handler.pbxConference(args.suId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pbxConference", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_answerCall(self, seqid, iprot, oprot):
        args = answerCall_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = answerCall_result()
        try:
            self._handler.answerCall(args.suId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("answerCall", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_answerSpecificCall(self, seqid, iprot, oprot):
        args = answerSpecificCall_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = answerSpecificCall_result()
        try:
            self._handler.answerSpecificCall(args.suId, args.lineName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("answerSpecificCall", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disconnectCall(self, seqid, iprot, oprot):
        args = disconnectCall_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disconnectCall_result()
        try:
            self._handler.disconnectCall(args.suId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disconnectCall", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hold(self, seqid, iprot, oprot):
        args = hold_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hold_result()
        try:
            self._handler.hold(args.suId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hold", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_commonHold(self, seqid, iprot, oprot):
        args = commonHold_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commonHold_result()
        try:
            self._handler.commonHold(args.suId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("commonHold", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_privateHold(self, seqid, iprot, oprot):
        args = privateHold_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = privateHold_result()
        try:
            self._handler.privateHold(args.suId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("privateHold", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_retrieveSpecific(self, seqid, iprot, oprot):
        args = retrieveSpecific_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = retrieveSpecific_result()
        try:
            self._handler.retrieveSpecific(args.suId, args.lineName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("retrieveSpecific", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dtmf(self, seqid, iprot, oprot):
        args = dtmf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dtmf_result()
        try:
            self._handler.dtmf(args.suId, args.digit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dtmf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLoginState(self, seqid, iprot, oprot):
        args = getLoginState_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLoginState_result()
        try:
            result.success = self._handler.getLoginState()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLoginState", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getVersion(self, seqid, iprot, oprot):
        args = getVersion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getVersion_result()
        try:
            result.success = self._handler.getVersion()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getVersion", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAvailableRingTransfers(self, seqid, iprot, oprot):
        args = getAvailableRingTransfers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAvailableRingTransfers_result()
        try:
            result.success = self._handler.getAvailableRingTransfers()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAvailableRingTransfers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshotRingTransfer(self, seqid, iprot, oprot):
        args = snapshotRingTransfer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshotRingTransfer_result()
        try:
            result.success = self._handler.snapshotRingTransfer(args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshotRingTransfer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setRingTransferActive(self, seqid, iprot, oprot):
        args = setRingTransferActive_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setRingTransferActive_result()
        try:
            self._handler.setRingTransferActive(args.id, args.active)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setRingTransferActive", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAvailableRingtransferSequences(self, seqid, iprot, oprot):
        args = getAvailableRingtransferSequences_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAvailableRingtransferSequences_result()
        try:
            result.success = self._handler.getAvailableRingtransferSequences()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAvailableRingtransferSequences", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshotRingTransferSequence(self, seqid, iprot, oprot):
        args = snapshotRingTransferSequence_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshotRingTransferSequence_result()
        try:
            result.success = self._handler.snapshotRingTransferSequence(args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshotRingTransferSequence", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setRingTransferSequenceActive(self, seqid, iprot, oprot):
        args = setRingTransferSequenceActive_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setRingTransferSequenceActive_result()
        try:
            self._handler.setRingTransferSequenceActive(args.id, args.active)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setRingTransferSequenceActive", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAvailableInterfaceActions(self, seqid, iprot, oprot):
        args = getAvailableInterfaceActions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAvailableInterfaceActions_result()
        try:
            result.success = self._handler.getAvailableInterfaceActions()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAvailableInterfaceActions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshotInterfaceAction(self, seqid, iprot, oprot):
        args = snapshotInterfaceAction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshotInterfaceAction_result()
        try:
            result.success = self._handler.snapshotInterfaceAction(args.apiName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshotInterfaceAction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setInterfaceActionState(self, seqid, iprot, oprot):
        args = setInterfaceActionState_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setInterfaceActionState_result()
        try:
            self._handler.setInterfaceActionState(args.apiName, args.state)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TurretApiException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setInterfaceActionState", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class requestNotifications_args(object):
    """
    Attributes:
     - subscriberInfo: SubscriberInfo IP address and port of the requesting client; Optionally contains turret display name

    """


    def __init__(self, subscriberInfo=None,):
        self.subscriberInfo = subscriberInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.subscriberInfo = SubscriberInfo()
                    self.subscriberInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('requestNotifications_args')
        if self.subscriberInfo is not None:
            oprot.writeFieldBegin('subscriberInfo', TType.STRUCT, 1)
            print("HHHHHHHHHHHHHHHHHHHHHHHHHHHH")
            self.subscriberInfo.write(oprot)
             print("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(requestNotifications_args)
requestNotifications_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'subscriberInfo', [SubscriberInfo, None], None, ),  # 1
)


class requestNotifications_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('requestNotifications_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(requestNotifications_result)
requestNotifications_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class getProfileList_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getProfileList_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getProfileList_args)
getProfileList_args.thrift_spec = (
)


class getProfileList_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = ProfileInfo()
                        _elem12.read(iprot)
                        self.success.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getProfileList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter13 in self.success:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getProfileList_result)
getProfileList_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ProfileInfo, None], False), None, ),  # 0
)


class getLoggedInProfileName_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLoggedInProfileName_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLoggedInProfileName_args)
getLoggedInProfileName_args.thrift_spec = (
)


class getLoggedInProfileName_result(object):
    """
    Attributes:
     - success
     - ex: :thrift:constant:`TurretApi.WrongLoginState` the turret is neither logged in nor in RCO mode

    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLoggedInProfileName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLoggedInProfileName_result)
getLoggedInProfileName_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class getSpeechUnits_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSpeechUnits_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSpeechUnits_args)
getSpeechUnits_args.thrift_spec = (
)


class getSpeechUnits_result(object):
    """
    Attributes:
     - success
     - ex: :thrift:constant:`TurretApi.WrongLoginState` if the turret is not logged in

    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = SpeechUnitConfiguration()
                        _elem19.read(iprot)
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSpeechUnits_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter20 in self.success:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSpeechUnits_result)
getSpeechUnits_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [SpeechUnitConfiguration, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class getAvailableLines_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAvailableLines_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAvailableLines_args)
getAvailableLines_args.thrift_spec = (
)


class getAvailableLines_result(object):
    """
    Attributes:
     - success
     - ex

    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAvailableLines_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter27 in self.success:
                oprot.writeString(iter27.encode('utf-8') if sys.version_info[0] == 2 else iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAvailableLines_result)
getAvailableLines_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class snapshotLineRequest_args(object):
    """
    Attributes:
     - lineName: Identifier of the requested line

    """


    def __init__(self, lineName=None,):
        self.lineName = lineName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.lineName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshotLineRequest_args')
        if self.lineName is not None:
            oprot.writeFieldBegin('lineName', TType.STRING, 1)
            oprot.writeString(self.lineName.encode('utf-8') if sys.version_info[0] == 2 else self.lineName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshotLineRequest_args)
snapshotLineRequest_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'lineName', 'UTF8', None, ),  # 1
)


class snapshotLineRequest_result(object):
    """
    Attributes:
     - success
     - ex

    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LineStatesData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshotLineRequest_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshotLineRequest_result)
snapshotLineRequest_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LineStatesData, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class snapshotCalls_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshotCalls_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshotCalls_args)
snapshotCalls_args.thrift_spec = (
)


class snapshotCalls_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = CallData()
                        _elem33.read(iprot)
                        self.success.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshotCalls_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter34 in self.success:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshotCalls_result)
snapshotCalls_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [CallData, None], False), None, ),  # 0
)


class login_args(object):
    """
    Attributes:
     - profileName: Name of the profile
     - password: Profile's password

    """


    def __init__(self, profileName=None, password=None,):
        self.profileName = profileName
        self.password = password

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.profileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('login_args')
        if self.profileName is not None:
            oprot.writeFieldBegin('profileName', TType.STRING, 1)
            oprot.writeString(self.profileName.encode('utf-8') if sys.version_info[0] == 2 else self.profileName)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 2)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(login_args)
login_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'profileName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'password', 'UTF8', None, ),  # 2
)


class login_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('login_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(login_result)
login_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class logout_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('logout_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(logout_args)
logout_args.thrift_spec = (
)


class logout_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('logout_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(logout_result)
logout_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class makeCall_args(object):
    """
    Attributes:
     - suId: Speech unit identifier
     - number: Telephone number to call

    """


    def __init__(self, suId=None, number=None,):
        self.suId = suId
        self.number = number

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.suId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.number = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('makeCall_args')
        if self.suId is not None:
            oprot.writeFieldBegin('suId', TType.I16, 1)
            oprot.writeI16(self.suId)
            oprot.writeFieldEnd()
        if self.number is not None:
            oprot.writeFieldBegin('number', TType.STRING, 2)
            oprot.writeString(self.number.encode('utf-8') if sys.version_info[0] == 2 else self.number)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(makeCall_args)
makeCall_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'suId', None, None, ),  # 1
    (2, TType.STRING, 'number', 'UTF8', None, ),  # 2
)


class makeCall_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('makeCall_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(makeCall_result)
makeCall_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class makeCallFromSpecificLine_args(object):
    """
    Attributes:
     - suId: Speech unit identifier
     - lineName: Line identifier from which the call will be initiated
     - number: Telephone number to call

    """


    def __init__(self, suId=None, lineName=None, number=None,):
        self.suId = suId
        self.lineName = lineName
        self.number = number

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.suId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.lineName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.number = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('makeCallFromSpecificLine_args')
        if self.suId is not None:
            oprot.writeFieldBegin('suId', TType.I16, 1)
            oprot.writeI16(self.suId)
            oprot.writeFieldEnd()
        if self.lineName is not None:
            oprot.writeFieldBegin('lineName', TType.STRING, 2)
            oprot.writeString(self.lineName.encode('utf-8') if sys.version_info[0] == 2 else self.lineName)
            oprot.writeFieldEnd()
        if self.number is not None:
            oprot.writeFieldBegin('number', TType.STRING, 3)
            oprot.writeString(self.number.encode('utf-8') if sys.version_info[0] == 2 else self.number)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(makeCallFromSpecificLine_args)
makeCallFromSpecificLine_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'suId', None, None, ),  # 1
    (2, TType.STRING, 'lineName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'number', 'UTF8', None, ),  # 3
)


class makeCallFromSpecificLine_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('makeCallFromSpecificLine_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(makeCallFromSpecificLine_result)
makeCallFromSpecificLine_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class createConsultation_args(object):
    """
    Attributes:
     - suId: Speech unit identifier
     - number: Telephone number to call

    """


    def __init__(self, suId=None, number=None,):
        self.suId = suId
        self.number = number

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.suId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.number = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createConsultation_args')
        if self.suId is not None:
            oprot.writeFieldBegin('suId', TType.I16, 1)
            oprot.writeI16(self.suId)
            oprot.writeFieldEnd()
        if self.number is not None:
            oprot.writeFieldBegin('number', TType.STRING, 2)
            oprot.writeString(self.number.encode('utf-8') if sys.version_info[0] == 2 else self.number)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createConsultation_args)
createConsultation_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'suId', None, None, ),  # 1
    (2, TType.STRING, 'number', 'UTF8', None, ),  # 2
)


class createConsultation_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createConsultation_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createConsultation_result)
createConsultation_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class transfer_args(object):
    """
    Attributes:
     - suId: Speech unit identifier

    """


    def __init__(self, suId=None,):
        self.suId = suId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.suId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('transfer_args')
        if self.suId is not None:
            oprot.writeFieldBegin('suId', TType.I16, 1)
            oprot.writeI16(self.suId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(transfer_args)
transfer_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'suId', None, None, ),  # 1
)


class transfer_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('transfer_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(transfer_result)
transfer_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class toggle_args(object):
    """
    Attributes:
     - suId: Speech unit identifier

    """


    def __init__(self, suId=None,):
        self.suId = suId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.suId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('toggle_args')
        if self.suId is not None:
            oprot.writeFieldBegin('suId', TType.I16, 1)
            oprot.writeI16(self.suId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(toggle_args)
toggle_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'suId', None, None, ),  # 1
)


class toggle_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('toggle_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(toggle_result)
toggle_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class pbxConference_args(object):
    """
    Attributes:
     - suId: Speech unit identifier

    """


    def __init__(self, suId=None,):
        self.suId = suId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.suId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pbxConference_args')
        if self.suId is not None:
            oprot.writeFieldBegin('suId', TType.I16, 1)
            oprot.writeI16(self.suId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pbxConference_args)
pbxConference_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'suId', None, None, ),  # 1
)


class pbxConference_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pbxConference_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pbxConference_result)
pbxConference_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class answerCall_args(object):
    """
    Attributes:
     - suId: Receiver speech unit's identifier

    """


    def __init__(self, suId=None,):
        self.suId = suId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.suId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('answerCall_args')
        if self.suId is not None:
            oprot.writeFieldBegin('suId', TType.I16, 1)
            oprot.writeI16(self.suId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(answerCall_args)
answerCall_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'suId', None, None, ),  # 1
)


class answerCall_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('answerCall_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(answerCall_result)
answerCall_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class answerSpecificCall_args(object):
    """
    Attributes:
     - suId: Receiver speech unit's identifier
     - lineName: Ringing line's identifier which will be picked up

    """


    def __init__(self, suId=None, lineName=None,):
        self.suId = suId
        self.lineName = lineName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.suId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.lineName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('answerSpecificCall_args')
        if self.suId is not None:
            oprot.writeFieldBegin('suId', TType.I16, 1)
            oprot.writeI16(self.suId)
            oprot.writeFieldEnd()
        if self.lineName is not None:
            oprot.writeFieldBegin('lineName', TType.STRING, 2)
            oprot.writeString(self.lineName.encode('utf-8') if sys.version_info[0] == 2 else self.lineName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(answerSpecificCall_args)
answerSpecificCall_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'suId', None, None, ),  # 1
    (2, TType.STRING, 'lineName', 'UTF8', None, ),  # 2
)


class answerSpecificCall_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('answerSpecificCall_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(answerSpecificCall_result)
answerSpecificCall_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class disconnectCall_args(object):
    """
    Attributes:
     - suId: Receiver speech unit's identifier

    """


    def __init__(self, suId=None,):
        self.suId = suId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.suId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disconnectCall_args')
        if self.suId is not None:
            oprot.writeFieldBegin('suId', TType.I16, 1)
            oprot.writeI16(self.suId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disconnectCall_args)
disconnectCall_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'suId', None, None, ),  # 1
)


class disconnectCall_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disconnectCall_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disconnectCall_result)
disconnectCall_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class hold_args(object):
    """
    Attributes:
     - suId: Speech unit identifier

    """


    def __init__(self, suId=None,):
        self.suId = suId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.suId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hold_args')
        if self.suId is not None:
            oprot.writeFieldBegin('suId', TType.I16, 1)
            oprot.writeI16(self.suId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hold_args)
hold_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'suId', None, None, ),  # 1
)


class hold_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hold_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hold_result)
hold_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class commonHold_args(object):
    """
    Attributes:
     - suId: Speech unit identifier

    """


    def __init__(self, suId=None,):
        self.suId = suId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.suId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commonHold_args')
        if self.suId is not None:
            oprot.writeFieldBegin('suId', TType.I16, 1)
            oprot.writeI16(self.suId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commonHold_args)
commonHold_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'suId', None, None, ),  # 1
)


class commonHold_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commonHold_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commonHold_result)
commonHold_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class privateHold_args(object):
    """
    Attributes:
     - suId: Speech unit identifier

    """


    def __init__(self, suId=None,):
        self.suId = suId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.suId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('privateHold_args')
        if self.suId is not None:
            oprot.writeFieldBegin('suId', TType.I16, 1)
            oprot.writeI16(self.suId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(privateHold_args)
privateHold_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'suId', None, None, ),  # 1
)


class privateHold_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('privateHold_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(privateHold_result)
privateHold_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class retrieveSpecific_args(object):
    """
    Attributes:
     - suId: Speech unit identifier
     - lineName: Unique name of the Line

    """


    def __init__(self, suId=None, lineName=None,):
        self.suId = suId
        self.lineName = lineName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.suId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.lineName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('retrieveSpecific_args')
        if self.suId is not None:
            oprot.writeFieldBegin('suId', TType.I16, 1)
            oprot.writeI16(self.suId)
            oprot.writeFieldEnd()
        if self.lineName is not None:
            oprot.writeFieldBegin('lineName', TType.STRING, 2)
            oprot.writeString(self.lineName.encode('utf-8') if sys.version_info[0] == 2 else self.lineName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(retrieveSpecific_args)
retrieveSpecific_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'suId', None, None, ),  # 1
    (2, TType.STRING, 'lineName', 'UTF8', None, ),  # 2
)


class retrieveSpecific_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('retrieveSpecific_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(retrieveSpecific_result)
retrieveSpecific_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class dtmf_args(object):
    """
    Attributes:
     - suId: Speech unit identifier
     - digit: DTMF digit to send

    """


    def __init__(self, suId=None, digit=None,):
        self.suId = suId
        self.digit = digit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.suId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.digit = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dtmf_args')
        if self.suId is not None:
            oprot.writeFieldBegin('suId', TType.I16, 1)
            oprot.writeI16(self.suId)
            oprot.writeFieldEnd()
        if self.digit is not None:
            oprot.writeFieldBegin('digit', TType.BYTE, 2)
            oprot.writeByte(self.digit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dtmf_args)
dtmf_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'suId', None, None, ),  # 1
    (2, TType.BYTE, 'digit', None, None, ),  # 2
)


class dtmf_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dtmf_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dtmf_result)
dtmf_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class getLoginState_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLoginState_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLoginState_args)
getLoginState_args.thrift_spec = (
)


class getLoginState_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLoginState_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLoginState_result)
getLoginState_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class getVersion_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getVersion_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getVersion_args)
getVersion_args.thrift_spec = (
)


class getVersion_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getVersion_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getVersion_result)
getVersion_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getAvailableRingTransfers_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAvailableRingTransfers_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAvailableRingTransfers_args)
getAvailableRingTransfers_args.thrift_spec = (
)


class getAvailableRingTransfers_result(object):
    """
    Attributes:
     - success
     - ex

    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = RingTransferId()
                        _elem40.read(iprot)
                        self.success.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAvailableRingTransfers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter41 in self.success:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAvailableRingTransfers_result)
getAvailableRingTransfers_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [RingTransferId, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class snapshotRingTransfer_args(object):
    """
    Attributes:
     - id

    """


    def __init__(self, id=None,):
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.id = RingTransferId()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshotRingTransfer_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 1)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshotRingTransfer_args)
snapshotRingTransfer_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'id', [RingTransferId, None], None, ),  # 1
)


class snapshotRingTransfer_result(object):
    """
    Attributes:
     - success
     - ex

    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshotRingTransfer_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshotRingTransfer_result)
snapshotRingTransfer_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class setRingTransferActive_args(object):
    """
    Attributes:
     - id
     - active

    """


    def __init__(self, id=None, active=None,):
        self.id = id
        self.active = active

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.id = RingTransferId()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.active = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setRingTransferActive_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 1)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        if self.active is not None:
            oprot.writeFieldBegin('active', TType.BOOL, 2)
            oprot.writeBool(self.active)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setRingTransferActive_args)
setRingTransferActive_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'id', [RingTransferId, None], None, ),  # 1
    (2, TType.BOOL, 'active', None, None, ),  # 2
)


class setRingTransferActive_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setRingTransferActive_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setRingTransferActive_result)
setRingTransferActive_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class getAvailableRingtransferSequences_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAvailableRingtransferSequences_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAvailableRingtransferSequences_args)
getAvailableRingtransferSequences_args.thrift_spec = (
)


class getAvailableRingtransferSequences_result(object):
    """
    Attributes:
     - success
     - ex

    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = RingTransferId()
                        _elem47.read(iprot)
                        self.success.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAvailableRingtransferSequences_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter48 in self.success:
                iter48.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAvailableRingtransferSequences_result)
getAvailableRingtransferSequences_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [RingTransferId, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class snapshotRingTransferSequence_args(object):
    """
    Attributes:
     - id

    """


    def __init__(self, id=None,):
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.id = RingTransferId()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshotRingTransferSequence_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 1)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshotRingTransferSequence_args)
snapshotRingTransferSequence_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'id', [RingTransferId, None], None, ),  # 1
)


class snapshotRingTransferSequence_result(object):
    """
    Attributes:
     - success
     - ex

    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshotRingTransferSequence_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshotRingTransferSequence_result)
snapshotRingTransferSequence_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class setRingTransferSequenceActive_args(object):
    """
    Attributes:
     - id
     - active

    """


    def __init__(self, id=None, active=None,):
        self.id = id
        self.active = active

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.id = RingTransferId()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.active = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setRingTransferSequenceActive_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 1)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        if self.active is not None:
            oprot.writeFieldBegin('active', TType.BOOL, 2)
            oprot.writeBool(self.active)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setRingTransferSequenceActive_args)
setRingTransferSequenceActive_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'id', [RingTransferId, None], None, ),  # 1
    (2, TType.BOOL, 'active', None, None, ),  # 2
)


class setRingTransferSequenceActive_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setRingTransferSequenceActive_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setRingTransferSequenceActive_result)
setRingTransferSequenceActive_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class getAvailableInterfaceActions_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAvailableInterfaceActions_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAvailableInterfaceActions_args)
getAvailableInterfaceActions_args.thrift_spec = (
)


class getAvailableInterfaceActions_result(object):
    """
    Attributes:
     - success
     - ex

    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAvailableInterfaceActions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter55 in self.success:
                oprot.writeString(iter55.encode('utf-8') if sys.version_info[0] == 2 else iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAvailableInterfaceActions_result)
getAvailableInterfaceActions_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class snapshotInterfaceAction_args(object):
    """
    Attributes:
     - apiName

    """


    def __init__(self, apiName=None,):
        self.apiName = apiName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.apiName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshotInterfaceAction_args')
        if self.apiName is not None:
            oprot.writeFieldBegin('apiName', TType.STRING, 1)
            oprot.writeString(self.apiName.encode('utf-8') if sys.version_info[0] == 2 else self.apiName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshotInterfaceAction_args)
snapshotInterfaceAction_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'apiName', 'UTF8', None, ),  # 1
)


class snapshotInterfaceAction_result(object):
    """
    Attributes:
     - success
     - ex

    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = InterfaceActionState()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshotInterfaceAction_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshotInterfaceAction_result)
snapshotInterfaceAction_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [InterfaceActionState, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)


class setInterfaceActionState_args(object):
    """
    Attributes:
     - apiName
     - state

    """


    def __init__(self, apiName=None, state=None,):
        self.apiName = apiName
        self.state = state

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.apiName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.state = InterfaceActionState()
                    self.state.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setInterfaceActionState_args')
        if self.apiName is not None:
            oprot.writeFieldBegin('apiName', TType.STRING, 1)
            oprot.writeString(self.apiName.encode('utf-8') if sys.version_info[0] == 2 else self.apiName)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.STRUCT, 2)
            self.state.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setInterfaceActionState_args)
setInterfaceActionState_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'apiName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'state', [InterfaceActionState, None], None, ),  # 2
)


class setInterfaceActionState_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = TurretApiException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setInterfaceActionState_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setInterfaceActionState_result)
setInterfaceActionState_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [TurretApiException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
