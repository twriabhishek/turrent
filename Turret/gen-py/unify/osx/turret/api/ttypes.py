#
# Autogenerated by Thrift Compiler (0.19.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class TurretState(object):
    Logout = 0
    ReceiveCallsOnly = 1
    Login = 2
    Unknown = 255

    _VALUES_TO_NAMES = {
        0: "Logout",
        1: "ReceiveCallsOnly",
        2: "Login",
        255: "Unknown",
    }

    _NAMES_TO_VALUES = {
        "Logout": 0,
        "ReceiveCallsOnly": 1,
        "Login": 2,
        "Unknown": 255,
    }


class DeviceType(object):
    Handset = 0
    Headset = 1
    MicrophoneWithoutSpeaker = 2
    MicrophoneWithSpeaker = 3

    _VALUES_TO_NAMES = {
        0: "Handset",
        1: "Headset",
        2: "MicrophoneWithoutSpeaker",
        3: "MicrophoneWithSpeaker",
    }

    _NAMES_TO_VALUES = {
        "Handset": 0,
        "Headset": 1,
        "MicrophoneWithoutSpeaker": 2,
        "MicrophoneWithSpeaker": 3,
    }


class BasicLineState(object):
    Idle = 0
    Ringing = 1
    Connected = 2
    Conversation = 3
    ConversationByAnother = 4
    PrivateHold = 5
    PrivateHoldByAnother = 6
    CommonHold = 7
    CommonHoldByAnother = 8
    Privacy = 9
    PrivacyByAnother = 10
    SpeechMonitoring = 11
    ConferenceHold = 12
    Inactive = 13
    SpeechMonitoringByAnother = 14
    Announcement = 15
    Preseized = 16
    PreseizedByAnother = 17
    HostingQuickConference = 18
    HostingConsultation = 19
    HostingPbxConference = 20
    ConsultationConnected = 21
    Unknown = 255

    _VALUES_TO_NAMES = {
        0: "Idle",
        1: "Ringing",
        2: "Connected",
        3: "Conversation",
        4: "ConversationByAnother",
        5: "PrivateHold",
        6: "PrivateHoldByAnother",
        7: "CommonHold",
        8: "CommonHoldByAnother",
        9: "Privacy",
        10: "PrivacyByAnother",
        11: "SpeechMonitoring",
        12: "ConferenceHold",
        13: "Inactive",
        14: "SpeechMonitoringByAnother",
        15: "Announcement",
        16: "Preseized",
        17: "PreseizedByAnother",
        18: "HostingQuickConference",
        19: "HostingConsultation",
        20: "HostingPbxConference",
        21: "ConsultationConnected",
        255: "Unknown",
    }

    _NAMES_TO_VALUES = {
        "Idle": 0,
        "Ringing": 1,
        "Connected": 2,
        "Conversation": 3,
        "ConversationByAnother": 4,
        "PrivateHold": 5,
        "PrivateHoldByAnother": 6,
        "CommonHold": 7,
        "CommonHoldByAnother": 8,
        "Privacy": 9,
        "PrivacyByAnother": 10,
        "SpeechMonitoring": 11,
        "ConferenceHold": 12,
        "Inactive": 13,
        "SpeechMonitoringByAnother": 14,
        "Announcement": 15,
        "Preseized": 16,
        "PreseizedByAnother": 17,
        "HostingQuickConference": 18,
        "HostingConsultation": 19,
        "HostingPbxConference": 20,
        "ConsultationConnected": 21,
        "Unknown": 255,
    }


class RingTransferState(object):
    Active = 0
    Inactive = 1

    _VALUES_TO_NAMES = {
        0: "Active",
        1: "Inactive",
    }

    _NAMES_TO_VALUES = {
        "Active": 0,
        "Inactive": 1,
    }


class RingTransferSequenceState(object):
    Active = 0
    Inactive = 1
    PartiallyActive = 2

    _VALUES_TO_NAMES = {
        0: "Active",
        1: "Inactive",
        2: "PartiallyActive",
    }

    _NAMES_TO_VALUES = {
        "Active": 0,
        "Inactive": 1,
        "PartiallyActive": 2,
    }


class InterfaceActionStateValue(object):
    Active = 0
    Inactive = 1
    State_A = 2
    State_B = 3
    State_C = 4
    State_D = 5
    State_E = 6
    State_F = 7
    State_G = 8
    State_H = 9
    State_I = 10
    State_J = 11
    State_K = 12
    State_L = 13
    State_M = 14
    State_N = 15
    State_O = 16
    State_P = 17
    State_Q = 18
    State_R = 19
    State_S = 20
    State_T = 21
    State_U = 22
    State_V = 23
    State_W = 24
    State_X = 25
    State_Y = 26
    State_Z = 27

    _VALUES_TO_NAMES = {
        0: "Active",
        1: "Inactive",
        2: "State_A",
        3: "State_B",
        4: "State_C",
        5: "State_D",
        6: "State_E",
        7: "State_F",
        8: "State_G",
        9: "State_H",
        10: "State_I",
        11: "State_J",
        12: "State_K",
        13: "State_L",
        14: "State_M",
        15: "State_N",
        16: "State_O",
        17: "State_P",
        18: "State_Q",
        19: "State_R",
        20: "State_S",
        21: "State_T",
        22: "State_U",
        23: "State_V",
        24: "State_W",
        25: "State_X",
        26: "State_Y",
        27: "State_Z",
    }

    _NAMES_TO_VALUES = {
        "Active": 0,
        "Inactive": 1,
        "State_A": 2,
        "State_B": 3,
        "State_C": 4,
        "State_D": 5,
        "State_E": 6,
        "State_F": 7,
        "State_G": 8,
        "State_H": 9,
        "State_I": 10,
        "State_J": 11,
        "State_K": 12,
        "State_L": 13,
        "State_M": 14,
        "State_N": 15,
        "State_O": 16,
        "State_P": 17,
        "State_Q": 18,
        "State_R": 19,
        "State_S": 20,
        "State_T": 21,
        "State_U": 22,
        "State_V": 23,
        "State_W": 24,
        "State_X": 25,
        "State_Y": 26,
        "State_Z": 27,
    }


class InterfaceActionKeyState(object):
    Pressed = 0
    Released = 1
    Clicked = 2

    _VALUES_TO_NAMES = {
        0: "Pressed",
        1: "Released",
        2: "Clicked",
    }

    _NAMES_TO_VALUES = {
        "Pressed": 0,
        "Released": 1,
        "Clicked": 2,
    }


class ProfileInfo(object):
    """
    Contains the name of the profile

    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ProfileInfo')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SpeechUnitConfiguration(object):
    """
    Contains the identifier and device type of a speech unit
    Used for getting speech unit configuration

    Attributes:
     - id
     - deviceType

    """


    def __init__(self, id=None, deviceType=None,):
        self.id = id
        self.deviceType = deviceType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.id = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.deviceType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpeechUnitConfiguration')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I16, 1)
            oprot.writeI16(self.id)
            oprot.writeFieldEnd()
        if self.deviceType is not None:
            oprot.writeFieldBegin('deviceType', TType.I32, 2)
            oprot.writeI32(self.deviceType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.deviceType is None:
            raise TProtocolException(message='Required field deviceType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LineStatesData(object):
    """
    Contains the name of a line and the composite state of the line.
    Used for snapshots about lines, and notification about state changes of the line.

    Attributes:
     - lineName: Unique name of the line
     - basicLineStates: Set of BasicLineStates of the line (as they are not all mutually exclusive)

    """


    def __init__(self, lineName=None, basicLineStates=None,):
        self.lineName = lineName
        self.basicLineStates = basicLineStates

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.lineName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.basicLineStates = set()
                    (_etype3, _size0) = iprot.readSetBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.basicLineStates.add(_elem5)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LineStatesData')
        if self.lineName is not None:
            oprot.writeFieldBegin('lineName', TType.STRING, 1)
            oprot.writeString(self.lineName.encode('utf-8') if sys.version_info[0] == 2 else self.lineName)
            oprot.writeFieldEnd()
        if self.basicLineStates is not None:
            oprot.writeFieldBegin('basicLineStates', TType.SET, 2)
            oprot.writeSetBegin(TType.I32, len(self.basicLineStates))
            for iter6 in self.basicLineStates:
                oprot.writeI32(iter6)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lineName is None:
            raise TProtocolException(message='Required field lineName is unset!')
        if self.basicLineStates is None:
            raise TProtocolException(message='Required field basicLineStates is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SubscriberInfo(object):
    """
    Contains information required to be able to subscribe for notifications.

    Attributes:
     - ipAddress: Specifies the notification receiver's IP address
     - port: Specifies the port the receiver is listening on
     - turretName: Notifications will contain this name for turret identification if the connecting client has to handle multiple turrets
    at the same time.
    This parameter is optional. If no turretName is provided, the notifications will be sent with an empty string as the name.

    """


    def __init__(self, ipAddress=None, port=None, turretName="",):
        self.ipAddress = ipAddress
        self.port = port
        self.turretName = turretName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ipAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.turretName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        print("::::::::::::::::::::::::")
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SubscriberInfo')
        if self.ipAddress is not None:
          
            oprot.writeFieldBegin('ipAddress', TType.STRING, 1)
            oprot.writeString(self.ipAddress.encode('utf-8') if sys.version_info[0] == 2 else self.ipAddress)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.turretName is not None:
            oprot.writeFieldBegin('turretName', TType.STRING, 3)
            oprot.writeString(self.turretName.encode('utf-8') if sys.version_info[0] == 2 else self.turretName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ipAddress is None:
            raise TProtocolException(message='Required field ipAddress is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CallData(object):
    """
    Contains information regarding calls.

       **Note:** The GUI shows this information in the following way:
       #. if :thrift:struct_field:`TurretApi.CallData.contactName` is not empty, then it is displayed.
       #. if :thrift:struct_field:`TurretApi.CallData.partyName` is not empty, then ``"{partyNumber} {partyName}"`` is displayed.
       #. in other cases, the :thrift:struct_field:`TurretApi.CallData.partyNumber` is diplayed.

    Attributes:
     - lineName: Name of the line the call is initiated from.
     - partyNumber: Number of the other party.
     - partyName: Name of the other party as provided by the PBX, encoded in UTF-8.
     - contactName: Name of the other party resolved from the contact list, encoded in UTF-8.
     - callId: Identifier of the call, unique in the context of the line.
     - active: `true` if this call is active on the line (i.e. it is not in the background in case of consultation)

    """


    def __init__(self, lineName=None, partyNumber=None, partyName=None, contactName=None, callId=None, active=None,):
        self.lineName = lineName
        self.partyNumber = partyNumber
        self.partyName = partyName
        self.contactName = contactName
        self.callId = callId
        self.active = active

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.lineName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.partyNumber = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.partyName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.contactName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.callId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.active = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CallData')
        if self.lineName is not None:
            oprot.writeFieldBegin('lineName', TType.STRING, 1)
            oprot.writeString(self.lineName.encode('utf-8') if sys.version_info[0] == 2 else self.lineName)
            oprot.writeFieldEnd()
        if self.partyNumber is not None:
            oprot.writeFieldBegin('partyNumber', TType.STRING, 2)
            oprot.writeString(self.partyNumber.encode('utf-8') if sys.version_info[0] == 2 else self.partyNumber)
            oprot.writeFieldEnd()
        if self.partyName is not None:
            oprot.writeFieldBegin('partyName', TType.STRING, 3)
            oprot.writeString(self.partyName.encode('utf-8') if sys.version_info[0] == 2 else self.partyName)
            oprot.writeFieldEnd()
        if self.contactName is not None:
            oprot.writeFieldBegin('contactName', TType.STRING, 4)
            oprot.writeString(self.contactName.encode('utf-8') if sys.version_info[0] == 2 else self.contactName)
            oprot.writeFieldEnd()
        if self.callId is not None:
            oprot.writeFieldBegin('callId', TType.STRING, 5)
            oprot.writeString(self.callId.encode('utf-8') if sys.version_info[0] == 2 else self.callId)
            oprot.writeFieldEnd()
        if self.active is not None:
            oprot.writeFieldBegin('active', TType.BOOL, 6)
            oprot.writeBool(self.active)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lineName is None:
            raise TProtocolException(message='Required field lineName is unset!')
        if self.partyNumber is None:
            raise TProtocolException(message='Required field partyNumber is unset!')
        if self.partyName is None:
            raise TProtocolException(message='Required field partyName is unset!')
        if self.contactName is None:
            raise TProtocolException(message='Required field contactName is unset!')
        if self.callId is None:
            raise TProtocolException(message='Required field callId is unset!')
        if self.active is None:
            raise TProtocolException(message='Required field active is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RingTransferId(object):
    """
    Contains information required to identify a ring transfer or a ring transfer sequence

    Attributes:
     - apiName: The API name of the ring transfer
     - controlledProfileName: The name of the controlled profile

    """


    def __init__(self, apiName=None, controlledProfileName=None,):
        self.apiName = apiName
        self.controlledProfileName = controlledProfileName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.apiName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.controlledProfileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RingTransferId')
        if self.apiName is not None:
            oprot.writeFieldBegin('apiName', TType.STRING, 1)
            oprot.writeString(self.apiName.encode('utf-8') if sys.version_info[0] == 2 else self.apiName)
            oprot.writeFieldEnd()
        if self.controlledProfileName is not None:
            oprot.writeFieldBegin('controlledProfileName', TType.STRING, 2)
            oprot.writeString(self.controlledProfileName.encode('utf-8') if sys.version_info[0] == 2 else self.controlledProfileName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.apiName is None:
            raise TProtocolException(message='Required field apiName is unset!')
        if self.controlledProfileName is None:
            raise TProtocolException(message='Required field controlledProfileName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InterfaceActionState(object):
    """
    Contains information about an interface action's state and the texts displayed on its button

    Attributes:
     - state: The state of the ring transfer
     - labelText: The overriding text for 'label'.
    Overriding means that it is an empty string in case of default text.
    It is optional only when used in setInterfaceActionState.
     - firstLineText: The text displayed on the first line.
    Overriding means that it is an empty string in case of default text.
    It is optional only when used in setInterfaceActionState.
     - secondLineText: The text displayed on the second line.
    Overriding means that it is an empty string in case of default text.
    It is optional only when used in setInterfaceActionState.

    """


    def __init__(self, state=None, labelText=None, firstLineText=None, secondLineText=None,):
        self.state = state
        self.labelText = labelText
        self.firstLineText = firstLineText
        self.secondLineText = secondLineText

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.labelText = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.firstLineText = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.secondLineText = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InterfaceActionState')
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.I32, 1)
            oprot.writeI32(self.state)
            oprot.writeFieldEnd()
        if self.labelText is not None:
            oprot.writeFieldBegin('labelText', TType.STRING, 2)
            oprot.writeString(self.labelText.encode('utf-8') if sys.version_info[0] == 2 else self.labelText)
            oprot.writeFieldEnd()
        if self.firstLineText is not None:
            oprot.writeFieldBegin('firstLineText', TType.STRING, 3)
            oprot.writeString(self.firstLineText.encode('utf-8') if sys.version_info[0] == 2 else self.firstLineText)
            oprot.writeFieldEnd()
        if self.secondLineText is not None:
            oprot.writeFieldBegin('secondLineText', TType.STRING, 4)
            oprot.writeString(self.secondLineText.encode('utf-8') if sys.version_info[0] == 2 else self.secondLineText)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TurretApiException(TException):
    """
    Exception type used to indicate that an error has occured.

    Attributes:
     - ErrorCode: Unique number indicating the error
     - ErrorAsString: Short description of the problem, useful for logging

    """


    def __init__(self, ErrorCode=None, ErrorAsString=None,):
        super(TurretApiException, self).__setattr__('ErrorCode', ErrorCode)
        super(TurretApiException, self).__setattr__('ErrorAsString', ErrorAsString)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.ErrorCode, self.ErrorAsString, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        ErrorCode = None
        ErrorAsString = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    ErrorCode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    ErrorAsString = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            ErrorCode=ErrorCode,
            ErrorAsString=ErrorAsString,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TurretApiException')
        if self.ErrorCode is not None:
            oprot.writeFieldBegin('ErrorCode', TType.I32, 1)
            oprot.writeI32(self.ErrorCode)
            oprot.writeFieldEnd()
        if self.ErrorAsString is not None:
            oprot.writeFieldBegin('ErrorAsString', TType.STRING, 2)
            oprot.writeString(self.ErrorAsString.encode('utf-8') if sys.version_info[0] == 2 else self.ErrorAsString)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ErrorCode is None:
            raise TProtocolException(message='Required field ErrorCode is unset!')
        if self.ErrorAsString is None:
            raise TProtocolException(message='Required field ErrorAsString is unset!')
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ProfileInfo)
ProfileInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)
all_structs.append(SpeechUnitConfiguration)
SpeechUnitConfiguration.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'id', None, None, ),  # 1
    (2, TType.I32, 'deviceType', None, None, ),  # 2
)
all_structs.append(LineStatesData)
LineStatesData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'lineName', 'UTF8', None, ),  # 1
    (2, TType.SET, 'basicLineStates', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(SubscriberInfo)
SubscriberInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ipAddress', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
    (3, TType.STRING, 'turretName', 'UTF8', "", ),  # 3
)
all_structs.append(CallData)
CallData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'lineName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'partyNumber', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'partyName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'contactName', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'callId', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'active', None, None, ),  # 6
)
all_structs.append(RingTransferId)
RingTransferId.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'apiName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'controlledProfileName', 'UTF8', None, ),  # 2
)
all_structs.append(InterfaceActionState)
InterfaceActionState.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'state', None, None, ),  # 1
    (2, TType.STRING, 'labelText', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'firstLineText', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'secondLineText', 'UTF8', None, ),  # 4
)
all_structs.append(TurretApiException)
TurretApiException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'ErrorCode', None, None, ),  # 1
    (2, TType.STRING, 'ErrorAsString', 'UTF8', None, ),  # 2
)
fix_spec(all_structs)
del all_structs
